import _extends from "@babel/runtime/helpers/extends";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
var _excluded = ["className", "value", "keyName", "parentName", "quotes", "label", "namespace", "editableValue", "onEdit", "highlightUpdates", "render"];
import { useEffect, useRef, useState } from 'react';
import { useHighlight } from '../semicolon';
import { Label } from '../value';
import { jsx as _jsx } from "react/jsx-runtime";
export var ObjectKey = props => {
  var {
      className,
      value,
      keyName,
      parentName,
      quotes,
      label,
      namespace,
      editableValue,
      onEdit,
      highlightUpdates = true,
      render
    } = props,
    reset = _objectWithoutPropertiesLoose(props, _excluded);
  var [editable, setEditable] = useState(false);
  var [curentLabel, setCurentLabel] = useState(label);
  useEffect(() => setCurentLabel(label), [label]);
  var $edit = useRef(null);
  useHighlight({
    value,
    highlightUpdates: highlightUpdates,
    highlightContainer: $edit
  });
  var click = evn => {
    evn.stopPropagation();
    if (!editableValue) return;
    if (typeof keyName !== 'string') return;
    if (editable) return;
    setEditable(true);
    if ($edit.current) {
      var _$edit$current;
      $edit.current.contentEditable = 'true';
      (_$edit$current = $edit.current) == null || _$edit$current.focus();
    }
  };
  var blur = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* () {
      if ($edit.current) {
        var _$edit$current2;
        if (onEdit) {
          var result = yield onEdit({
            value: $edit.current.innerText,
            oldValue: curentLabel,
            namespace,
            keyName,
            parentName,
            type: 'key'
          });
          if (result) {
            setCurentLabel($edit.current.innerText);
          } else {
            $edit.current.innerText = curentLabel;
          }
        }
        $edit.current.contentEditable = 'false';
        (_$edit$current2 = $edit.current) == null || _$edit$current2.focus();
      }
      setEditable(false);
    });
    return function blur() {
      return _ref.apply(this, arguments);
    };
  }();
  var focus = () => {
    if ($edit.current) {
      var _$edit$current3;
      $edit.current.contentEditable = 'true';
      (_$edit$current3 = $edit.current) == null || _$edit$current3.focus();
    }
  };
  var keyDown = evn => {
    if (evn.key === 'Enter') {
      evn.stopPropagation();
      evn.preventDefault();
      $edit.current.contentEditable = 'false';
    }
  };
  useEffect(() => {
    if ($edit.current) {
      $edit.current.addEventListener('paste', e => {
        e.preventDefault();
        // @ts-ignore
        var text = e.clipboardData.getData('text/plain');
        document.execCommand('insertHTML', false, text);
      });
    }
  }, [$edit]);
  var style = {
    minWidth: 34,
    minHeight: 18,
    paddingInline: 3,
    display: 'inline-block'
  };
  var content = typeof keyName === 'string' ? "" + quotes + curentLabel + quotes : curentLabel;
  var spanProps = {
    onClick: click,
    onFocus: focus,
    onBlur: blur,
    onKeyDown: keyDown,
    style: editable ? style : {},
    contentEditable: editable,
    spellCheck: false,
    autoFocus: editable,
    suppressContentEditableWarning: true,
    children: editable ? curentLabel : content
  };
  if (render) {
    spanProps.value = value;
    spanProps.keyName = keyName;
    spanProps.parentName = parentName;
    return render(_extends({
      className
    }, reset, spanProps, {
      parentName,
      label: curentLabel,
      children: editable ? curentLabel : content,
      ref: $edit
    }));
  }
  return /*#__PURE__*/_jsx(Label, _extends({
    className: className
  }, reset, {
    autoFocus: editable
  }, spanProps, {
    ref: $edit
  }));
};
ObjectKey.displayName = 'JVR.ObjectKey';